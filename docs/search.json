[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 fPASS authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Salil Koner. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Koner S (2023). fPASS: Two Sample Projection-based Test Mean function Functional Data. R package version 1.0.0.0, https://github.com/SalilKoner/fPASS.","code":"@Manual{,   title = {fPASS: Two Sample Projection-based Test of Mean function for Functional Data},   author = {Salil Koner},   year = {2023},   note = {R package version 1.0.0.0},   url = {https://github.com/SalilKoner/fPASS}, }"},{"path":"/index.html","id":"fpass-an-r-package-for-power-and-sample-size-analysis-pass-for-projection-based-two-sample-test-for-functional-data","dir":"","previous_headings":"","what":"Two Sample Projection-based Test of Mean function for Functional\n    Data","title":"Two Sample Projection-based Test of Mean function for Functional\n    Data","text":"Salil Koner details testing procedure, please see Wang (2021) univariate case, Koner Luo (2023) multivariate case.","code":""},{"path":[]},{"path":"/index.html","id":"installation","dir":"","previous_headings":"Details","what":"Installation","title":"Two Sample Projection-based Test of Mean function for Functional\n    Data","text":"install, can either download directory build install package command line (e.g. R CMD BUILD fPASS followed R CMD INSTALL fPASS_1.0.0.0.tar.gz). can also install package using devtools::install_github follows.","code":"library(devtools) devtools::install_github(repo = \"SalilKoner/fPASS\")"},{"path":"/reference/Extract_Eigencomp_fDA.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"function Extract_Eigencomp_fDA() computes eigenfunctions covariance shrinkage scores required conduct projection-based test mean function two groups longitudinal data sparsely observed functional data random irregular design, developed Wang (2021).","code":""},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"","code":"Extract_Eigencomp_fDA(   nobs_per_subj,   obs.design,   mean_diff_fnm,   cov.type = c(\"ST\", \"NS\"),   cov.par,   sigma2.e,   missing_type = c(\"nomiss\", \"constant\"),   missing_percent = 0,   eval_SS = 5000,   alloc.ratio = c(1, 1),   fpca_method = c(\"fpca.sc\", \"face\"),   data.driven.scores = FALSE,   mean_diff_add_args = list(),   fpca_optns = list() )"},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"nobs_per_subj number observations per subject. element must greater 3. also vector indicate number observation randomly varying elements vector, scalar ensure number observations subject. See examples. obs.design sampling design observations. Must provided list following elements. design longitudinal (e.g. clinical trial pre-specified schedule visit participants) must named list elements design, visit.schedule visit.window, obs.design$design must specified 'longitudinal', visit.schedule specifying schedule visits (months days unit time), baseline visit visit.window denoting maximum time window every visit. functional design (observation points either densely observed within compact interval sparse random design), argument must provided named list elementsdesign fun.domain, obs.design$design must specified 'functional' obs.design$fun.domain must specified two length vector indicating domain function. See Details specification arguments section details. mean_diff_fnm name function output difference mean two groups given time. must supplied character, match.fun(mean_diff_fnm) returns valid function, takes vector input, returns vector length input. cov.type type covariance structure data, must either 'ST' (stationary) 'NS' (non-stationary). argument along cov.par argument must specified compatibly ensure function return error. See details cov.par argument. cov.par covariance structure latent response trajectory. cov.type == 'ST' , cov.par must specified named list two elements, var cor, var common variance observations, must positive number; cor specifies correlation structure observations. cov.par$cor must specified form nlme::corClasses specified R package nlme. Check package documentation details correlation classes. cov.par$cor must corStruct class can passed onto nlme::corMatrix() extract subject-specific covariance matrix. cov.type='NS' , cov.par must named list two elements, cov.obj eigen.comp, one cov.par$cov.obj cov.par$eigen.comp must non-null. specify covariance structure latent trajectory can either provided form covariance function form eigenfunction eigenvalues (Spectral decomposition). cov.par$cov.obj specified, must bivariate function, two arguments. Alternatively, true eigenfunctions  known, user can specify specifying cov.par$eigen.comp. case, cov.par$eigen.comp must named list two elements, eig.obj eig.val, cov.par$eigen.comp$eig.val must positive vector cov.par$eigen.comp$eig.obj must vectorized function evaluation vector time points returns matrix dimension r length(cov.par$eigen.comp$eig.val), r length time points. sigma2.e Measurement error variance, set zero small number measurement error significant. missing_type type missing number observations subjects. Can one 'nomiss' missing observations 'constant' constant missing percentage every time point. current version package supports missing_type = 'constant'. missing_percent percentage missing observation points subject. nobs_per_subj supplied vector, missing_type forced set 'nomiss' missing_percent = 0, missing_type = 'constant' meaning number observations varying subject first, typically considered case sparse random functional design. eval_SS sample size based eigencomponents estimated data. compute theoretical power test must make sure use large enough sample size generate data estimated eigenfunctions close true eigenfunctions sampling design much effect loss precision. Default value 5000. alloc.ratio allocation ratio samples group. Note eigenfunctions still estimated based total sample_size, however, variance shrinkage scores (required compute power function) estimated based allocation samples group. Must given vector length 2. Default value set c(1,1), indicating equal sample size. fpca_method method FPCA computed. Must one 'fpca.sc' 'face'. fpca_method == 'fpca.sc' eigencomponents estimated using function refund::fpca.sc(). However, since refund::fpca.sc() function fails estimate correct shrinkage scores, throws NA values measurement errors estimated zero, wrote similar function corrected error current version refund::fpca.sc(). Check fpca.sc() function details. fpca_method == 'face', eigencomponents estimated using face::face.sparse() function. data.driven.scores Indicates whether scores estimated full data, WITHOUT assuming mean function unknown, rather mean function estimated using mgcv::gam() function. mean_diff_add_args Additional arguments passed group difference function specified argument mean_diff_fnm. fpca_optns Additional options passed onto either fpca.sc() face::face.sparse() function order estimate eigencomponents. must named list elements passed onto respective function, depending fpca_method.","code":""},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"list elements listed . mean_diff_vec - evaluation mean function working grid. est_eigenfun - evaluation estimated eigenfunctions working grid. est_eigval - Estimated eigen values. working.grid - grid points mean_diff_vec est_eigenfun evaluated. weights - Gaussian quadrature weights obtained gss::gauss.quad() compute projection \\(\\int [\\mu_1(t) - \\mu_2(t)]\\phi_k(t) \\,dt\\), \\(k=1,\\dots, K\\). fpcCall - exact call either fpca.sc() face::face.sparse() used compute eigencomponents. scores_var1 - Estimated covariance shrinkage scores treatment group. scores_var2 - Estimated covariance shrinkage scores placebo group. pooled_var  - Pooled covariance scores combining groups. required user wants compute power Hotelling T statistic equal variance assumption. data.driven.scores ==  TRUE additional components returned scores_1 - Estimated shrinkage scores subjects treatment group. scores_2 - Estimated shrinkage scores subjects placebo group. output function designed way user can directly input output obtained function arguments Power_Proj_Test_ufDA() function obtain power sample size right away. function PASS_Proj_Test_ufDA , essentially wrapper ofExtract_Eigencomp_fDA() Power_Proj_Test_ufDA() together.","code":""},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"function can handle data wide variety covariance structure, can parametric, non-parametric. Additional traditional stationary structures assumed longitudinal data (see nlme::corClasses), user can specify non-stationary covariance function form either covariance function terms eigenfunctions eigenvalues. user lot flexibility tweaking arguments nobs_per_subject, obs.design, cov.par compute eigencomponents different sampling design covariance process response trajectory, arbitrary mean difference function. Internally, using sampling design covariance structure specified, generate large data large number subjects, estimate eigenfunctions covariance estimated shrinkage scores means functional principal component analysis (fPCA). put option using two commonly used softwares fPCA functional data literature, refund::fpca.sc() face::face.sparse(). However, since refund::fpca.sc() compute shrinkage scores correctly, especially measurement error variance estimated zero, made duplicate version version write scoring part . new function named fpca.sc(), please check .","code":""},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"details-on-the-specification-of-arguments-","dir":"Reference","previous_headings":"","what":"Details on the specification of arguments.","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"obs.design$design == 'functional' dense grid length, specified ngrid (typically 101/201) internally created, observation points randomly chosen . time points also randomly chosen number interval, large number subject, fpca.sc() function take huge time estimate eigenfunction. dense design, user must set large value argument nobs_per_subj sparse (random) design, nobs_per_subj set small (varying). hand, typical longitudinal data, measurements taken fixed time points (baseline) subject, user must set obs.design$design == 'longitudinal' time points must accordingly specified argument obs.design$visit.schedule. length obs.design$visit.schedule must match length(nobs_per_subj)-1. Internally, obs.design$design == 'longitudinal', function scale visit times lies \\([0,1]\\), user specify element named fun.domain list obs.design$design == 'longitudinal'. Make sure mean function covariance function specified cov.par mean_diff_fnm parameter also scaled take argument \\([0,1]\\). Also, imperative say nobs_per_subj must scalar positive integer design == 'longitudinal'.","code":""},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"Wang, Qiyao (2021) Two-sample inference sparse functional data,  Electronic Journal Statistics, Vol. 15, 1395-1423 doi:10.1214/21-EJS1802 .","code":""},{"path":[]},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"Salil Koner  Maintainer: Salil Koner salil.koner@duke.edu","code":""},{"path":"/reference/Extract_Eigencomp_fDA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract/estimate eigenfunction from a sparse functional or longitudinal design\nby simulating from a large number of subjects. — Extract_Eigencomp_fDA","text":"","code":"if (FALSE) { set.seed(12345) mean.diff <- function(t) {t}; obs.design <- list(\"design\" = \"longitudinal\", \"visit.schedule\" = seq(0.1, 0.9, length.out=7), \"visit.window\" = 0.05) cor.str <- nlme::corExp(1, form = ~ time | Subject); sigma2 <- 1; sigma2.e <- 0.25; nobs_per_subj <- 8; missing_type <- \"constant\"; missing_percent <- 0.01; eigencomp  <- Extract_Eigencomp_fDA(obs.design = obs.design, mean_diff_fnm = \"mean.diff\", cov.type = \"ST\", cov.par = list(\"var\" = sigma2, \"cor\" = cor.str), sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj, missing_type = missing_type, missing_percent = missing_percent, eval_SS = 5000, alloc.ratio = c(1,1), fpca_method = \"fpca.sc\", data.driven.scores = FALSE, mean_diff_add_args = list(), fpca_optns = list(pve = 0.95)) } if (FALSE) { alloc.ratio  <- c(1,1) mean.diff    <- function(t) {1 * (t^3)}; eig.fun <- function(t, k) { if (k==1) { ef <- sqrt(2)*sin(2*pi*t) } else if (k==2) {ef <- sqrt(2)*cos(2*pi*t)} return(ef)} eig.fun.vec  <- function(t){cbind(eig.fun(t, 1),eig.fun(t, 2))} eigen.comp   <- list(\"eig.val\" = c(1, 0.5), \"eig.obj\" = eig.fun.vec) obs.design   <- list(design = \"functional\", fun.domain = c(0,1)) cov.par      <- list(\"cov.obj\" = NULL, \"eigen.comp\" = eigen.comp) sigma2.e     <- 0.001; nobs_per_subj <- 4:7; missing_type <- \"nomiss\"; missing_percent <- 0; fpca_method  <- \"fpca.sc\" eigencomp  <- Extract_Eigencomp_fDA(obs.design = obs.design,  mean_diff_fnm = \"mean.diff\",  cov.type = \"NS\", cov.par = cov.par,  sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,  missing_type = missing_type,  missing_percent = missing_percent, eval_SS = 5000,  alloc.ratio = alloc.ratio,  fpca_method = \"fpca.sc\", data.driven.scores = FALSE,  mean_diff_add_args = list(), fpca_optns = list(pve = 0.95)) }"},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":null,"dir":"Reference","previous_headings":"","what":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"function PASS_Proj_Test_ufDA() computes power sample size (PASS) required conduct projection-based test mean function two groups longitudinal data sparsely observed functional data random irregular design, common covariance structure groups. See Wang (2021) details testing procedure.","code":""},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"","code":"PASS_Proj_Test_ufDA(   sample_size,   target.power,   sig.level = 0.05,   nobs_per_subj,   obs.design,   mean_diff_fnm,   cov.type = c(\"ST\", \"NS\"),   cov.par,   sigma2.e,   missing_type = c(\"nomiss\", \"constant\"),   missing_percent = 0,   eval_SS = 5000,   alloc.ratio = c(1, 1),   fpca_method = c(\"fpca.sc\", \"face\"),   mean_diff_add_args = list(),   fpca_optns = list(pve = 0.95),   npc_to_use = NULL,   return.eigencomp = FALSE )"},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"sample_size Total sample size combining groups, must positive integer. target.power Target power achieve, must number 0 1. one sample_size target.power non-null. function return sample size sample_size NULL, return power target.power NULL. sig.level Significance level test, default set 0.05, must less 0.2. nobs_per_subj number observations per subject. element must greater 3. also vector indicate number observation randomly varying elements vector, scalar ensure number observations subject. See examples. obs.design sampling design observations. Must provided list following elements. design longitudinal (e.g. clinical trial pre-specified schedule visit participants) must named list elements design, visit.schedule visit.window, obs.design$design must specified 'longitudinal', visit.schedule specifying schedule visits (months days unit time), baseline visit visit.window denoting maximum time window every visit. functional design (observation points either densely observed within compact interval sparse random design), argument must provided named list elementsdesign fun.domain, obs.design$design must specified 'functional' obs.design$fun.domain must specified two length vector indicating domain function. See Details specification arguments section details. mean_diff_fnm name function output difference mean two groups given time. must supplied character, match.fun(mean_diff_fnm) returns valid function, takes vector input, returns vector length input. cov.type type covariance structure data, must either 'ST' 'NS'. argument along cov.par argument must specified compatibly ensure function return error. See details cov.par argument. cov.par covariance structure latent response trajectory. cov.type == 'ST' , cov.par must specified named list two elements, var cor, var common variance observations, must positive number; cor specifies correlation structure observations. cov.par$cor must specified form nlme::corClasses specified R package nlme. Check package documentation details correlation classes. cov.par$cor must corStruct class can passed onto nlme::corMatrix() extract subject-specific covariance matrix. cov.type='NS' , cov.par must named list two elements, cov.obj eigen.comp, one cov.par$cov.obj cov.par$eigen.comp must non-null. specify covariance structure latent trajectory can either provided form covariance function form eigenfunction eigenvalues (Spectral decomposition). cov.par$cov.obj specified, must bivariate function, two arguments. Alternatively, true eigenfunctions  known, user can specify specifying cov.par$eigen.comp. case, cov.par$eigen.comp must named list two elements, eig.obj eig.val, cov.par$eigen.comp$eig.val must positive vector cov.par$eigen.comp$eig.obj must vectorized function evaluation vector time points returns matrix dimension r length(cov.par$eigen.comp$eig.val), r length time points. sigma2.e Measurement error variance, set zero small number measurement error significant. missing_type type missing number observations subjects. Can one 'nomiss' missing observations 'constant' constant missing percentage every time point. current version package supports missing_type = 'constant'. missing_percent percentage missing observation points subject. nobs_per_subj supplied vector, missing_type forced set 'nomiss' missing_percent = 0, missing_type = 'constant' meaning number observations varying subject first, typically considered case sparse random functional design. eval_SS sample size based eigencomponents estimated data. compute theoretical power test must make sure use large enough sample size generate data estimated eigenfunctions close true eigenfunctions sampling design much effect loss precision. Default value 5000. alloc.ratio allocation ratio samples group. Note eigenfunctions still estimated based total sample_size, however, variance shrinkage scores (required compute power function) estimated based allocation samples group. Must given vector length 2. Default value set c(1,1), indicating equal sample size. fpca_method method FPCA computed. Must one 'fpca.sc' 'face'. fpca_method == 'fpca.sc' eigencomponents estimated using function refund::fpca.sc(). However, since refund::fpca.sc() function fails estimate correct shrinkage scores, throws NA values measurement errors estimated zero, wrote similar function corrected error current version refund::fpca.sc(). Check fpca.sc() function details. fpca_method == 'face', eigencomponents estimated using face::face.sparse() function. mean_diff_add_args Additional arguments passed group difference function specified argument mean_diff_fnm. fpca_optns Additional options passed onto either fpca.sc() face::face.sparse() function order estimate eigencomponents. must named list elements passed onto respective function, depending fpca_method. npc_to_use Number eigenfunctions use compute power. Default NULL, case eigenfunctions estimated data used. return.eigencomp Indicates whether return eigencomponents obtained fPCA large data sample size equal eval_SS. Default FALSE.","code":""},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"list following elements, power_value .null(target.power) returns power test n equal sample_size, otherwise required_SS, sample size required achieve power test target.power. return.eigencomp == TRUE est_eigencomp also returned, containing entire output obtained internal call Extract_Eigencomp_fDA().","code":""},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"function designed perform power sample size analysis functional dense sparse (random) design longitudinal data. function can handle data wide variety covariance structure, can parametric, non-parametric. Additional traditional stationary structures assumed longitudinal data (see nlme::corClasses), user can specify non-stationary covariance function form either covariance function terms eigenfunctions eigenvalues. user lot flexibility tweaking arguments function assess power function test different sampling design covariance process response trajectory, arbitrary mean difference function. Overall, functionality module quite comprehensive includes different cases considered NCSS PASS software. believe software can effective clinical trial design tools considering projection-based test primary decision making method.","code":""},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"details-on-the-specification-of-arguments-","dir":"Reference","previous_headings":"","what":"Details on the specification of arguments.","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"obs.design$design == 'functional' dense grid length, specified ngrid (typically 101/201) internally created, observation points randomly chosen . time points also randomly chosen number interval, large number subject, fpca.sc() function take huge time estimate eigenfunction. dense design, user must set large value argument nobs_per_subj sparse (random) design, nobs_per_subj set small (varying). hand, typical longitudinal data, measurements taken fixed time points (baseline) subject, user must set obs.design$design == 'longitudinal' time points must accordingly specified argument obs.design$visit.schedule. length obs.design$visit.schedule must match length(nobs_per_subj)-1. Internally, obs.design$design == 'longitudinal', function scale visit times lies \\([0,1]\\), user specify element named fun.domain list obs.design$design == 'longitudinal'. Make sure mean function covariance function specified cov.par mean_diff_fnm parameter also scaled take argument \\([0,1]\\). Also, imperative say nobs_per_subj must scalar positive integer design == 'longitudinal'.","code":""},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"Wang, Qiyao (2021) Two-sample inference sparse functional data,  Electronic Journal Statistics, Vol. 15, 1395-1423 doi:10.1214/21-EJS1802 .","code":""},{"path":[]},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"Salil Koner  Maintainer: Salil Koner salil.koner@duke.edu","code":""},{"path":"/reference/PASS_Proj_Test_ufDA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power and Sample size (PASS) calculation of\nTwo-Sample Projection-based test for sparsely observed univariate functional data. — PASS_Proj_Test_ufDA","text":"","code":"if (FALSE) { set.seed(12345) mean.diff <- function(t) {0*t}; obs.design = list(\"design\" = \"longitudinal\",                   \"visit.schedule\" = seq(0.1, 0.9, length.out=7),                    \"visit.window\" = 0.05) cor.str <- nlme::corExp(1, form = ~ time | Subject); sigma2 <- 1; sigma2.e <- 0.25; nobs_per_subj <- 8; missing_type <- \"constant\"; missing_percent <- 0.01; pow  <- PASS_Proj_Test_ufDA(sample_size = 100, target.power = NULL, sig.level = 0.05,                             obs.design = obs.design,                             mean_diff_fnm = \"mean.diff\", cov.type = \"ST\",                             cov.par = list(\"var\" = sigma2, \"cor\" = cor.str),                             sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,                             missing_type = missing_type,                             missing_percent = missing_percent, eval_SS = 5000,                             alloc.ratio = c(1,1),                             fpca_method = \"fpca.sc\",                             mean_diff_add_args = list(), fpca_optns = list(\"pve\" = 0.95))  pow$power_value } if (FALSE) { alloc.ratio  <- c(1,1) mean.diff    <- function(t) {1 * (t^3)}; eig.fun <- function(t, k) {   if (k==1) ef <- sqrt(2)*sin(2*pi*t)   else if (k==2) ef <- sqrt(2)*cos(2*pi*t)   return(ef)} eig.fun.vec  <- function(t){cbind(eig.fun(t, 1),eig.fun(t, 2))} eigen.comp   <- list(\"eig.val\" = c(1, 0.5), \"eig.obj\" = eig.fun.vec) obs.design   <- list(design = \"functional\", fun.domain = c(0,1)) cov.par      <- list(\"cov.obj\" = NULL, \"eigen.comp\" = eigen.comp) sigma2.e     <- 0.001; nobs_per_subj <- 4:7; missing_type <- \"nomiss\"; missing_percent <- 0; fpca_method  <- \"fpca.sc\" pow  <- PASS_Proj_Test_ufDA(sample_size = 100, target.power = NULL,                             sig.level = 0.05, obs.design = obs.design,                             mean_diff_fnm = \"mean.diff\", cov.type = \"NS\",                             cov.par = cov.par, sigma2.e = sigma2.e,                             nobs_per_subj = nobs_per_subj, missing_type = missing_type,                             missing_percent = missing_percent, eval_SS = 5000,                             alloc.ratio = alloc.ratio, fpca_method = \"fpca.sc\",                             mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))  pow$power_value } if (FALSE) { alloc.ratio  <- c(1,1) mean.diff    <- function(t) {1 * (t^3)}; eig.fun <- function(t, k) {   if (k==1) ef <- sqrt(2)*sin(2*pi*t)   else if (k==2) ef <- sqrt(2)*cos(2*pi*t)   return(ef)} eig.fun.vec  <- function(t){cbind(eig.fun(t, 1),eig.fun(t, 2))} eigen.comp   <- list(\"eig.val\" = c(1, 0.5), \"eig.obj\" = eig.fun.vec) obs.design   <- list(design = \"functional\", fun.domain = c(0,1)) cov.par      <- list(\"cov.obj\" = NULL, \"eigen.comp\" = eigen.comp) sigma2.e     <- 0.001; nobs_per_subj <- 4:7; missing_type <- \"nomiss\"; missing_percent <- 0; fpca_method  <- \"fpca.sc\" pow  <- PASS_Proj_Test_ufDA(sample_size = NULL, target.power = 0.8,                             sig.level = 0.05, obs.design = obs.design,                             mean_diff_fnm = \"mean.diff\", cov.type = \"NS\",                             cov.par = cov.par, sigma2.e = sigma2.e,                             nobs_per_subj = nobs_per_subj, missing_type = missing_type,                             missing_percent = missing_percent, eval_SS = 5000,                             alloc.ratio = alloc.ratio, fpca_method = \"fpca.sc\",                             mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))  pow$required_SS }"},{"path":"/reference/Power_Proj_Test_ufDA.html","id":null,"dir":"Reference","previous_headings":"","what":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"function Power_Proj_Test_ufDA() computes power two-sample projection-based test functional response data setting, group difference, eigenfunctions covariance data specified dense grid time points, along (estimated) covariance shrinkage scores.","code":""},{"path":"/reference/Power_Proj_Test_ufDA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"","code":"Power_Proj_Test_ufDA(   total_sample_size,   argvals,   mean_vector,   eigen_matrix,   scores_var1,   scores_var2,   weights,   sig.level = 0.05,   alloc.ratio = c(1, 1),   npc_to_pick = ncol(eigen_matrix) )"},{"path":"/reference/Power_Proj_Test_ufDA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"total_sample_size Total sample size combing two groups, must positive integer. argvals working grid timepoints evaluate eigenfunctions mean functions. preferred take working grid dense grid \\(\\int [\\mu_1(t) - \\mu_2(t)]\\phi_k(t) \\,dt\\) can calculated required precision. mean_vector difference mean function evaluated argvals, must numeric vector length argavls. eigen_matrix matrix eigenfunctions evaluated argvals, must length(argvals) K matrix, K number eigenfunctions. scores_var1 true (estimate) covariance matrix shrinkage scores first group. Must symmetric (.symmetric(scores_var1) == TRUE) positive definite (chol(scores_var1) without error!). scores_var2 true (estimate) covariance matrix shrinkage scores second group. Must symmetric (.symmetric(scores_var2) == TRUE) positive definite (chol(scores_var2) without error!). weights weights put compute projection \\(\\int [\\mu_1(t) - \\mu_2(t)]\\phi_k(t) \\,dt\\), \\(k=1,\\dots, K\\). integral numerically approximated sum(mean_diff(argvals)*eigen_matrix[,k]*weights). sig.level Significance level test, default set 0.05, must less 0.2. used compute critical value test. alloc.ratio Allocation total sample size two groups. Must set vector two positive numbers. equal allocation put c(1,1), non-equal allocation one can put c(2,1) c(3,1) etc. Default set c(1,1). npc_to_pick Number eigenfunction used compute power. Typically becomes handy user want discard last eigenfunctions, typically small eigenvalues.","code":""},{"path":"/reference/Power_Proj_Test_ufDA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"Power projection-based test specified difference mean function eigencomponents covariance functional data.","code":""},{"path":"/reference/Power_Proj_Test_ufDA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"projection-based test first extracts K eigenfunctions data, project mean difference function onto eigenfunctions obtain K-dimensional projection vector reflects group difference. Wang (2021) pointed null hypothesis covariance K-dimensional functional principal component analysis (fPCA) scores , thus Hotelling \\(T^2\\) test assuming equal variance shrinkage scores valid test. However, Koner Luo (2023) pointed alternate hypothesis, difference mean significant, covariance shrinkage scores also differ groups. Therefore, computing power test, must derive distribution Hotelling \\(T^2\\) statistic assumption unequal variance. alogrithm power multivariate Hotelling \\(T^2\\) unequal variance coded pHotellingT() function. particular function wrapper around function, inputs mean difference function, eigenfunctions scores, subsequently call pHotellingT() function compute power unequal variance. See Koner Luo (2023) details formula non-null distribution.","code":""},{"path":"/reference/Power_Proj_Test_ufDA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"Wang, Qiyao (2021) Two-sample inference sparse functional data,  Electronic Journal Statistics, Vol. 15, 1395-1423 doi:10.1214/21-EJS1802 .","code":""},{"path":[]},{"path":"/reference/Power_Proj_Test_ufDA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"Salil Koner  Maintainer: Salil Koner salil.koner@duke.edu","code":""},{"path":"/reference/Power_Proj_Test_ufDA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Power of the Two-sample Projection-based test for functional data with known (or estimated)\neigencomponents. — Power_Proj_Test_ufDA","text":"","code":"if (FALSE) { ngrid          <- 101 interval       <- c(-1,1) gauss.quad.pts <- gss::gauss.quad(ngrid,interval) # evaluation points working.grid   <- gauss.quad.pts$pt mean_fn        <- function(t) {0.4*sin(2*pi*t)} mean_vector    <- mean_fn(working.grid) eigen_fn       <- function(t, k){ sqrt(2)*{(k==2)*sin(2*pi*t) + (k==1)*cos(2*pi*t)} } eigen_matrix   <- cbind(eigen_fn(working.grid,1), eigen_fn(working.grid,2)) mean_proj      <- sapply(1:2, function(r) integrate(function(x) eigen_fn(x,r)*mean_fn(x), interval[1], interval[2])$value) sig1           <- diag(2) sig2           <- 2*diag(2) alp            <- 0.05 n              <- 100 k              <- ncol(eigen_matrix) cutoff         <- {(n - 2)*k/(n - k -1)}*qf(1-alp, k, n-k-1) func_power     <- Power_Proj_Test_ufDA(total_sample_size=n, argvals=working.grid, mean_vector = mean_vector, eigen_matrix = eigen_matrix, scores_var1 = sig1, scores_var2= sig2, weights = gauss.quad.pts$wt, sig.level=alp, alloc.ratio = c(1,1), npc_to_pick=ncol(eigen_matrix)) }"},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"function Sim_HotellingT_unequal_var() generates samples (non-null) distribution two-sample Hotelling-\\(T^2\\) statistic assuming unequal covariance multivariate response two groups. function used compute power function Two-Sample (TS) Projection-based test (Wang 2021, EJS.) sparsely observed univariate functional data.","code":""},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"","code":"Sim_HotellingT_unequal_var(   total_sample_size,   mean_diff,   sig1,   sig2,   alloc.ratio = c(1, 1),   nsim = 10000 )"},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"total_sample_size Target sample size, must positive integer. mean_diff difference mean vector two groups, must vector. sig1 true (estimate) covariance matrix first group. Must symmetric (.symmetric(sig1) == TRUE) positive definite (chol(sig1) without error!). sig2 true (estimate) covariance matrix second group. Must symmetric (.symmetric(sig2) == TRUE) positive definite (chol(sig2) without error!). alloc.ratio Allocation total sample size two groups. Must set vector two positive numbers. equal allocation put c(1,1), non-equal allocation one can put c(2,1) c(3,1) etc. nsim number samples generated alternate distribution.","code":""},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"named list two elements. samples - vector length nsim, containing samples distribution Hotelling T statistic unequal variance. denom.df - denominator degrees freedom chi-square statistic obtained approximation sum two Wishart distribution unequal variance.","code":""},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"assumption equal variance, know alternative distribution Hotelling-\\(T^2\\) statistic F distribution non-centrality depending difference true mean vectors (common) covariance response. However, true covariance true groups responses differ, alternate distribution becomes non-trivial. Koner Luo (2023) proved alternate distribution test-statistic approximately follows ratio linear combination K (dimension response) non-central chi-squared random variables (non-centrality parameter depends mean difference) chi-squared distribution whose degrees freedom depends complicated functions sample size two groups. See Koner Luo (2023) details formula non-null distribution.","code":""},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"Wang, Qiyao (2021) Two-sample inference sparse functional data,  Electronic Journal Statistics, Vol. 15, 1395-1423 doi:10.1214/21-EJS1802 .","code":""},{"path":[]},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"Salil Koner  Maintainer: Salil Koner salil.koner@duke.edu","code":""},{"path":"/reference/Sim_HotellingT_unequal_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Samples from the non-null distribution of the Hotelling-\\(T^2\\) statistic under unequal covariance. — Sim_HotellingT_unequal_var","text":"","code":"if (FALSE) { # In both the samples we assume that the covariances differ as the # mean vector between the two groups differ. # Case 1: Null hypothesis is true. True mean difference is zero, and the true # covariance of the two groups are same. k <- 5 mu1  <- rep(0,k); del  <- 0; mu2 <- mu1 + rep(del, k); sig1 <- diag(k); sig2 <- sig1 + del*toeplitz(c(1,rep(0.5, k-1))); n <- 200; null.dist.samples <- Sim_HotellingT_unequal_var(total_sample_size=n, mean_diff=mu1-mu2,                      sig1=sig1, sig2=sig2, alloc.ratio=c(1,1), nsim=1e3) # The following Kolmogorov Smirnov test confirms that under null hypothesis # and when the covariances are same, the distribution is exactly a # central F distribution with \\eqn{k} and \\eqn{n-k}  degrees of freedom. ks.test(null.dist.samples$samples, {{(n - 2) * k}/(n - k -1)} * {rf(n=1e3, k, n-k-1)} ) } if (FALSE) { # Case 2: Alternate hypothesis is true. The mean difference is non-zero, # and the covariances of the two groups are same: k <- 6 mu1  <- rep(0,k); del  <- 0.15; mu2 <- mu1 + rep(del, k); sig1 <- diag(k); sig2 <- sig1; n1 <- 100; n2 <- 100; alt.dist.samples <- Sim_HotellingT_unequal_var(total_sample_size=n1+n2, mean_diff=mu1-mu2,                                                sig1=sig1, sig2=sig2, alloc.ratio=c(1,1), nsim=1e3) ks.test(alt.dist.samples$samples,         {(n1+n2 - 2) * k /(n1+n2 - k -1)}*rf(n=B, k, n1+n2-k-1,           ncp = {(n1*n2)/(n1+n2)}*as.vector(crossprod(mu1-mu2, solve(sig1, mu1-mu2))) ) ) } if (FALSE) { # Case 3: Alternate hypothesis is true. The mean difference is non-zero, # and the covariances of the two groups are different k <- 5 mu1  <- rep(0,k); del  <- 0.25; mu2 <- mu1 + rep(del, k); sig1 <- diag(k); sig2 <- sig1 + del*toeplitz(c(1,rep(0.5, k-1))) alt.dist.samples <- Sim_HotellingT_unequal_var(total_sample_size=200, mean_diff=mu1-mu2, sig1=sig1, sig2=sig2, alloc.ratio=c(1,1), nsim=1e3) } if (FALSE) { # Generate samples with unequal allocation ratio: k <- 8 mu1  <- rep(0,k); del  <- 0.4; mu2 <- mu1 + rep(del, k); sig1 <- diag(k); sig2 <- sig1 + del*toeplitz(c(1,rep(0.5, k-1))) alt.dist.samples <- Sim_HotellingT_unequal_var(total_sample_size=150, mean_diff=mu1-mu2, sig1=sig1, sig2=sig2, alloc.ratio=c(2,1), nsim=1e3) }"},{"path":"/reference/fPASS-package.html","id":null,"dir":"Reference","previous_headings":"","what":"fPASS package — fPASS-package","title":"fPASS package — fPASS-package","text":"See README GitHub","code":""},{"path":"/reference/fPASS-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"fPASS package — fPASS-package","text":"R package fPASS designed perform power sample size analysis functional dense sparse (random) design longitudinal data. function can handle data wide variety covariance structure, can parametric, non-parametric. user lot flexibility tweaking arguments function assess power function test different sampling design covariance process response trajectory, arbitrary mean difference function. Overall, functionality module quite comprehensive includes different cases considered NCSS PASS software. believe software can effective clinical trial design tools considering projection-based test primary decision making method.","code":""},{"path":[]},{"path":"/reference/fPASS-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fPASS package — fPASS-package","text":"Maintainer: Salil Koner salil.koner@duke.edu (ORCID)","code":""},{"path":"/reference/fpca.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional principal components analysis by smoothed covariance — fpca.sc","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"Decomposes functional observations using functional principal components analysis. mixed model framework used estimate scores obtain variance estimates.","code":""},{"path":"/reference/fpca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"","code":"fpca.sc(   Y = NULL,   ydata = NULL,   Y.pred = NULL,   argvals = NULL,   random.int = FALSE,   nbasis = 10,   pve = 0.95,   npc = NULL,   useSymm = FALSE,   makePD = FALSE,   center = TRUE,   cov.est.method = 2,   integration = \"trapezoidal\" )"},{"path":"/reference/fpca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"Y, ydata user must supply either Y, matrix functions observed regular grid, data frame ydata representing irregularly observed functions. See Details. Y.pred desired, matrix functions approximated using FPC decomposition. argvals argument values function evaluations Y, defaults equidistant grid 0 1. random.int TRUE, mean estimated gamm4 random intercepts. FALSE (default), mean estimated gam treating data independent. nbasis number B-spline basis functions used estimation mean function bivariate smoothing covariance surface. pve proportion variance explained: used choose number principal components. npc prespecified value number principal components (given, overrides pve). useSymm logical, indicating whether smooth upper triangular part naive covariance (cov.est.method==2). can save computation time large data sets, allows covariance surfaces peaked diagonal. makePD logical: positive definiteness enforced covariance surface estimate? center logical: estimated mean function subtracted Y? Set FALSE already demeaned data using favorite mean function estimate. cov.est.method covariance estimation method. set 1, one-step method applies bivariate smooth \\(y(s_1)y(s_2)\\) values. can slow. set 2 (default), two-step method obtains naive covariance estimate smoothed. integration quadrature method numerical integration; 'trapezoidal' currently supported.","code":""},{"path":"/reference/fpca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"object class fpca containing: Yhat FPC approximation (projection onto leading components) Y.pred specified, else Y. Y observed data scores \\(n \\times npc\\) matrix estimated FPC scores. mu estimated mean function (vector zeroes center==FALSE). efunctions \\(d \\times npc\\) matrix estimated eigenfunctions functional covariance, .e., FPC basis functions. evalues estimated eigenvalues covariance operator, .e., variances FPC scores. npc number FPCs: either supplied npc, minimum number basis functions needed explain proportion pve variance observed curves. argvals argument values eigenfunction evaluations sigma2 estimated measurement error variance. diag.var diagonal elements covariance matrices estimated curve. VarMats list containing estimated covariance matrices curve Y. crit.val estimated critical values constructing simultaneous confidence intervals.","code":""},{"path":"/reference/fpca.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"function computes FPC decomposition set observed curves, may sparsely observed /measured error. mixed model framework used estimate curve-specific scores variances. FPCA via kernel smoothing covariance function, diagonal treated separately, proposed Staniswalis Lee (1998) much extended Yao et al. (2005), introduced 'PACE' method. fpca.sc uses penalized splines smooth covariance function, developed Di et al. (2009) Goldsmith et al. (2013). functional data must supplied either \\(n \\times d\\) matrix Y, row one functional observation, missing values allowed; data frame ydata, columns '.id' (curve point belongs , say \\(\\)), '.index' (function argument time point \\(t\\)), '.value' (observed function value \\(Y_i(t)\\)).","code":""},{"path":"/reference/fpca.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"Di, C., Crainiceanu, C., Caffo, B., Punjabi, N. (2009). Multilevel functional principal component analysis. Annals Applied Statistics, 3, 458--488. Goldsmith, J., Greven, S., Crainiceanu, C. (2013). Corrected confidence bands functional data using principal components. Biometrics, 69(1), 41--51. Staniswalis, J. G., Lee, J. J. (1998). Nonparametric regression analysis longitudinal data. Journal American Statistical Association, 93, 1403--1418. Yao, F., Mueller, H.-G., Wang, J.-L. (2005). Functional data analysis sparse longitudinal data. Journal American Statistical Association, 100, 577--590.","code":""},{"path":"/reference/fpca.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"Jeff Goldsmith jeff.goldsmith@columbia.edu, Sonja Greven sonja.greven@stat.uni-muenchen.de, Lan Huo Lan.Huo@nyumc.org, Lei Huang huangracer@gmail.com, Philip Reiss phil.reiss@nyumc.org","code":""},{"path":"/reference/fpca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional principal components analysis by smoothed covariance — fpca.sc","text":"","code":"if (FALSE) { library(ggplot2) library(reshape2) data(cd4)  Fit.MM = fpca.sc(cd4, var = TRUE, simul = TRUE)  Fit.mu = data.frame(mu = Fit.MM$mu,                     d = as.numeric(colnames(cd4))) Fit.basis = data.frame(phi = Fit.MM$efunctions,                        d = as.numeric(colnames(cd4)))  ## for one subject, examine curve estimate, pointwise and simultaneous itervals EX = 1 EX.MM = data.frame(fitted = Fit.MM$Yhat[EX,],            ptwise.UB = Fit.MM$Yhat[EX,] + 1.96 * sqrt(Fit.MM$diag.var[EX,]),            ptwise.LB = Fit.MM$Yhat[EX,] - 1.96 * sqrt(Fit.MM$diag.var[EX,]),            simul.UB = Fit.MM$Yhat[EX,] + Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),            simul.LB = Fit.MM$Yhat[EX,] - Fit.MM$crit.val[EX] * sqrt(Fit.MM$diag.var[EX,]),            d = as.numeric(colnames(cd4)))  ## plot data for one subject, with curve and interval estimates EX.MM.m = melt(EX.MM, id = 'd') ggplot(EX.MM.m, aes(x = d, y = value, group = variable, color = variable, linetype = variable)) +   geom_path() +   scale_linetype_manual(values = c(fitted = 1, ptwise.UB = 2,                         ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +   scale_color_manual(values = c(fitted = 1, ptwise.UB = 2,                      ptwise.LB = 2, simul.UB = 3, simul.LB = 3)) +   labs(x = 'Months since seroconversion', y = 'Total CD4 Cell Count')  ## plot estimated mean function ggplot(Fit.mu, aes(x = d, y = mu)) + geom_path() +   labs(x = 'Months since seroconversion', y = 'Total CD4 Cell Count')  ## plot the first two estimated basis functions Fit.basis.m = melt(Fit.basis, id = 'd') ggplot(subset(Fit.basis.m, variable %in% c('phi.1', 'phi.2')), aes(x = d, y = value, group = variable, color = variable)) + geom_path()  ## input a dataframe instead of a matrix nid <- 20 nobs <- sample(10:20, nid, rep=TRUE) ydata <- data.frame(     .id = rep(1:nid, nobs),     .index = round(runif(sum(nobs), 0, 1), 3)) ydata$.value <- unlist(tapply(ydata$.index,                               ydata$.id,                               function(x)                                   runif(1, -.5, .5) +                                   dbeta(x, runif(1, 6, 8), runif(1, 3, 5))                               )                        )  Fit.MM = fpca.sc(ydata=ydata, var = TRUE, simul = FALSE)  }"},{"path":"/reference/pHotellingT.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","title":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","text":"function pHotellingT() computes cumulative distribution function (CDF) two-sample Hotelling-\\(T^2\\) statistic (\\(P(T > q)\\)) multivariate response setting. function used compute power function Two-Sample (TS) Projection-based test (Wang 2021, EJS.) sparsely observed univariate functional data.","code":""},{"path":"/reference/pHotellingT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","text":"","code":"pHotellingT(   q,   total_sample_size,   mean_diff,   sig1,   sig2,   alloc.ratio = c(1, 1),   lower.tail = TRUE )"},{"path":"/reference/pHotellingT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","text":"q point CDF needs evaluated total_sample_size Target sample size, must positive integer. mean_diff difference mean vector two groups, must vector. sig1 true (estimate) covariance matrix first group. Must symmetric (.symmetric(sig1) == TRUE) positive definite (chol(sig1) without error!). sig2 true (estimate) covariance matrix second group. Must symmetric (.symmetric(sig2) == TRUE) positive definite (chol(sig2) without error!). alloc.ratio Allocation total sample size two groups. Must set vector two positive numbers. equal allocation put c(1,1), non-equal allocation one can put c(2,1) c(3,1) etc. lower.tail TRUE, CDF returned, otherwise right tail probability returned.","code":""},{"path":"/reference/pHotellingT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","text":"CDF Hotelling T statistic, lower.tail == TRUE, otherwise right tail probability returned.","code":""},{"path":"/reference/pHotellingT.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","text":"assumption equal variance, know alternative distribution Hotelling-\\(T^2\\) statistic (\\((n-k-1)T/(n-2)*K\\)) F distribution non-centrality depending difference true mean vectors (common) covariance response. However, true covariance true groups responses differ, alternate distribution becomes non-trivial. Koner Luo (2023) proved alternate distribution test-statistic approximately follows ratio linear combination K (dimension response) non-central chi-squared random variables (non-centrality parameter depends mean difference) chi-squared distribution whose degrees freedom depends complicated functions sample size two groups. function initially calls Sim_HotellingT_unequal_var function obtain samples non-null distribution computes CDF numerically high precision based large number samples. See Koner Luo (2023) details formula non-null distribution.","code":""},{"path":[]},{"path":"/reference/pHotellingT.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","text":"Salil Koner  Maintainer: Salil Koner salil.koner@duke.edu","code":""},{"path":"/reference/pHotellingT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CDF of Hotelling-\\(T^2\\) statistic. — pHotellingT","text":"","code":"if (FALSE) { B           <- 10000 k           <- 4 n2          <- 60 n1_by_n2    <- 2 n1          <- n1_by_n2 * n2 mu1         <- rep(0,k) del         <- 0.4 mu2         <- mu1 + rep(del, k) # rep(0.19,k)  # 0.23 (0.9), 0.18 (0.7) 0.20 (0.8) sig1        <- diag(k) sig2        <- sig1 cutoff      <- seq(0,30, length.out=20) the_cdf     <- round(pHotellingT(cutoff, n1+n2, mu1 - mu2,                                  sig1, sig2, alloc.ratio=c(2,1),                                  lower.tail=FALSE),3) }"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
