% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Extract_Eigencomp_fDA.R
\name{Extract_Eigencomp_fDA}
\alias{Extract_Eigencomp_fDA}
\title{Extract/estimate eigenfunction from a sparse functional or longitudinal design
by simulating from a large number of subjects.}
\usage{
Extract_Eigencomp_fDA(
  nobs_per_subj,
  obs.design,
  mean_diff_fnm,
  cov.type = c("ST", "NS"),
  cov.par,
  sigma2.e,
  missing_type = c("nomiss", "constant"),
  missing_percent = 0,
  eval_SS = 5000,
  alloc.ratio = c(1, 1),
  fpca_method = c("fpca.sc", "face"),
  data.driven.scores = FALSE,
  mean_diff_add_args = list(),
  fpca_optns = list()
)
}
\arguments{
\item{nobs_per_subj}{The number of observations per subject. Each element of it greater than 3.
Could be a vector to specify that the number of observation for each is randomly varying
between the elements of the vector, or a scalar to ensure that the number of observations are same
for each subject.}

\item{obs.design}{The sampling design of the observations. Must be provided as a list with the following elements.
For functional design it must be provided as a named list with elements "design" and "fun.domain", where for example,
design = "functional" and \code{fun.domain = c(0,1)}, specifying the domain of the functions. For longitudinal design,
it must be a named list with elements "design", "visit.schedule" and "visit.window", where the last two elements
specifying schedule of visits (in months or days or any scale), other than the baseline visit
and the maximum time window for every visit, which is also for every visit other than the baseline. See examples.}

\item{mean_diff_fnm}{The name of the function representing the group difference. Must be supplied as character.}

\item{cov.type}{The type of the covariance structure of the data, must be either of "ST" (stationary) or
"NS" (non-stationary)}

\item{cov.par}{The covariance parameters that needs to be specified.
If \code{cov.type='ST'} then, cov.par
must be a named list of two elements, "var" and "cor", where "var" denotes
the common variance of the observations, must be a positive number; and "cor" denotes
The correlation structure between the observations.
It must be provided in the form specified in the
available in the documentation of R package \pkg{nlme}. Check the package documentation for more details.
The argument of this function is passed onto the \code{\link[nlme:corMatrix]{nlme::corMatrix()}} to extract the subject-specific
covariance matrix.
If \code{cov.type='NS'} then, cov.par
must be a named list of two elements, "cov.obj" and "eigen.comp".
Only one of the "cov.obj" or "eigen.comp" must be non-null. If the "cov.obj" is
specified, then it must be either a bivariate function. Alternatively,
if the true eigenfunctions (and number of eigenfunctions, say K) are known,
then the user can specify that by specifying eigen.comp.
In this case, the eigen.comp must be a named list with two elements,
"eig.obj" and "eig.val".
The object "eig.obj" must be a function so that the code \code{eigen.comp$eig.obj(timepoints)}
returns a matrix of dimension r by K, where r is the length of \code{timepoints} and K
is the number of eigenfunctions.}

\item{sigma2.e}{Measurement error variance, should be set as zero if there is no measurement error.}

\item{missing_type}{The type of missing in the number of observations of the subjects. Can be one of
\code{missing_type = "nomiss"} for no missing observations
or \code{missing_type = "constant"} for constant
missing. Only supports \code{missing_type = "constant"} now. Note that, if
nobs_per_subj is specified as vector,
\code{missing_type} is forced to set as "nomiss" and \code{missing_percent = 0}, because
the \code{missing_type = "constant"} has no meaning if the number of observations are
varying between the subject at the first, typically considered in
the case of sparse random functional design.}

\item{missing_percent}{The percentage of missing at each observation points for each subject.}

\item{eval_SS}{The sample size based on which the eigenfunctions will be estimated from data.
To compute the theoretical power of the test we must make sure that we use a large enough sample size
to generate the data such that the estimated eigenfunctions are very close to the true eigenfunctions
and that the sampling design will not have much effect on the loss of precision. Default value 5000.}

\item{alloc.ratio}{The allocation ratio of samples in the each group. Note that the eigenfunctions will still
be estimated based on the total eval_SS, however, the variance of the shrinkage scores will be
estimated based on the allocation of the samples in each group. Must be given as vector of
length 2. Default value is set at c(1,1), indicating equal sample size.}

\item{fpca_method}{The method by which the FPCA is computed. Must be one of c("fpca.sc", "face").}

\item{data.driven.scores}{Indicates whether the scores are estimated from the full data, WITHOUT
assuming the mean function is unknown, rather the mean function is estimated using
\code{\link[mgcv:gam]{mgcv::gam()}} function.}

\item{mean_diff_add_args}{Additional arguments to be passed to the mean_diff
function specified by the name \code{mean_diff_fnm}.}

\item{fpca_optns}{Additional options to be passed onto either of \code{\link[refund:fpca.sc]{refund::fpca.sc()}}
or \code{\link[face:face.sparse]{face::face.sparse()}} function in order
to estimate the eigencomponents. It must be a named list with elements
to be passed onto the respective function, depending on the \code{fpca_method}.}
}
\value{
Returns the estimated eigenfunctions and the covariance of the shrinkage scores for the
for the two groups, as well as the combined covariances assuming that they have the same o
covariances.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

This function \code{Extract_Eigencomp_fDA()} computes the eigenfunctions and the
covariance of the shrinkage scoresrequired to conduct
the projection-based test of mean function between two groups of longitudinal data
or sparsely observed functional data under a random irregular design, as developed by Koner and Luo (2023).
}
\details{
The projection-based test assumes the two groups of the data share the identical
covariance structure. We allow the covariance structure of the data as both parametric
and non-parametric. If the covariance structure is non-parametric, then, the user must specify the
the covariance function in the form of a function.
The projection-based test represents the sparsely observed
functions parsimoniously in terms of Karhunen-Loeve (KL) expansion and use the
functional principal component analysis scores to test the difference in the mean
function between two groups, by taking advantage of multivariate Hotelling-\eqn{T^2} test.
See Wang (2021) for more details of the testing procedure. We use the \code{fpca.sc()} which
is a just a copy of \code{\link[refund:fpca.sc]{refund::fpca.sc()}} function to account for the shrinkage correctly,
or \code{\link[face:face.sparse]{face::face.sparse()}} function to conduct the functional principal component analysis (fPCA).
\subsection{Details on the specification of arguments.}{

If \code{obs.design$design == "functional"} then a dense grid of length, specified by ngrid (typically 101/201) is internally created, and
the observation points will be randomly chosen from them. The time points could also randomly chosen between
any number between the interval, but then for large number of subject, \code{\link[=fpca.sc]{fpca.sc()}} function will take huge
time to estimate the eigenfunction. For dense design, the user must set a large value of the argument
\code{nobs_per_subj} and for sparse (random) design, \code{nobs_per_subj} should be set small (and varying).
On the other hand, typical to longitudinal data, if the measurements are taken at fixed time points (from baseline)
for each subject, then the user must set \code{obs.design$design == "longitudinal"} and the time points must be accordingly specified
in the argument \code{obs.design$visit.schedule}. The length of \code{obs.design$visit.schedule} must match \code{length(nobs_per_subj)-1}.
so that it lies between \eqn{[0,1]}, so user should not specify any "fun.domain" in the
list for obs.design$design == "longitudinal". Make sure that the mean_function and the covariance function specified
in the \code{cov.par} and \code{mean_diff_fnm} parameter also scaled to take argument between \eqn{[0,1]}.
Also, it is imperative to say that \code{nobs_per_subj} must be of a scalar positive inter for \code{design == "longitudinal"}.
}
}
\examples{
\dontrun{
set.seed(12345)
mean.diff <- function(t) {t};
obs.design <- list("design" = "functional",
"visit.schedule" = seq(0.1, 0.9, length.out=7),
"visit.window" = 0.05)
cor.str <- nlme::corExp(1, form = ~ time | Subject);
sigma2 <- 1; sigma2.e <- 0.25; nobs_per_subj <- 6;
missing_type <- "constant"; missing_percent <- 0.01;
eigencomp  <- extract_eigencomp_fDA(obs.design = obs.design,
mean_diff_fnm = "mean.diff", cov.type = "ST",
cov.par = list("var" = sigma2, "cor" = cor.str),
sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,
missing_type = missing_type,
missing_percent = missing_percent, eval_SS = 5000,
alloc.ratio = c(1,1),
fpca_method = "fpca.sc", data.driven.scores = FALSE,
mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))
}
\dontrun{
alloc.ratio  <- c(1,1)
mean.diff    <- function(t) {1 * (t^3)};
eig.fun <- function(t, k) { if (k==1) {
ef <- sqrt(2)*sin(2*pi*t)
} else if (k==2) {ef <- sqrt(2)*cos(2*pi*t)}
return(ef)}
eig.fun.vec  <- function(t){cbind(eig.fun(t, 1),eig.fun(t, 2))}
eigen.comp   <- list("eig.val" = c(1, 0.5), "eig.obj" = eig.fun)
obs.design   <- list(design = "functional", fun.domain = c(0,1))
cov.par      <- list("cov.obj" = NULL, "eigen.comp" = eigen.comp)
sigma2.e     <- 0.001; nobs_per_subj <- 4:7;
missing_type <- "nomiss"; missing_percent <- 0;
fpca_method  <- "fpca.sc"
eigencomp  <- extract_eigencomp_fDA(obs.design = obs.design,
 mean_diff_fnm = "mean.diff",
 cov.type = "NS", cov.par = cov.par,
 sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,
 missing_type = missing_type,
 missing_percent = missing_percent, eval_SS = 5000,
 alloc.ratio = alloc.ratio,
 fpca_method = "fpca.sc", data.driven.scores = FALSE,
 mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))
}
}
\references{
Wang, Qiyao (2021)
\emph{Two-sample inference for sparse functional data,  Electronic Journal of Statistics,
Vol. 15, 1395-1423} \cr
\doi{https://doi.org/10.1214/21-EJS1802}.
}
\seealso{
See \code{\link[=Power_Proj_Test_ufDA]{Power_Proj_Test_ufDA()}} and \code{\link[=pHotellingT]{pHotellingT()}}.
}
\author{
Salil Koner \cr Maintainer: Salil Koner
\email{salil.koner@duke.edu}
}
